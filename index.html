<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ULTRA MILK</title>
<style>
  html, body {
    margin:0; padding:0; height:100%; overflow:hidden;
    background:#000;
    font-family: monospace, monospace;
    user-select:none;
  }
  canvas { display:block; }
  #titleScreen, #pauseMenu {
    position: absolute;
    top:0; left:0; width:100%; height:100%;
    background: black;
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 99;
  }
  #titleScreen h1 {
    font-size: 4em;
    margin: 0;
    font-weight: bold;
  }
  #loadingBarContainer {
    width: 80%;
    height: 20px;
    background: #444;
    border-radius: 10px;
    margin-top: 20px;
    overflow: hidden;
  }
  #loadingBar {
    height: 100%;
    width: 0%;
    background: #f8f8f8;
    border-radius: 10px;
  }
  #pauseMenu {
    display:none;
    flex-direction: row;
    justify-content: space-between;
    padding: 40px;
  }
  #pauseLeft {
    flex:1;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
  }
  #pauseLeft button {
    padding: 12px 20px;
    font-size: 18px;
    margin-bottom: 20px;
    background: #222;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    user-select:none;
    width: 160px;
  }
  #pauseRight {
    flex:1;
    display: flex;
    flex-direction: column;
    align-items: center;
    color: white;
  }
  #milkmanSprite {
    width: 120px;
    height: 160px;
    background: url('https://i.imgur.com/qXuObXa.png') no-repeat center/contain;
    margin-bottom: 20px;
  }
  #weaponSlots {
    display: flex;
    gap: 20px;
  }
  .weaponSlot {
    width: 80px;
    height: 80px;
    background: #222;
    border-radius: 12px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 14px;
    user-select:none;
  }
  #crosshair {
    position: absolute;
    top:50%; left:50%;
    width: 6px; height: 6px;
    margin-left: -3px; margin-top: -3px;
    background: white;
    z-index: 20;
  }
  #hud {
    position: absolute;
    bottom: 20px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    color: white;
    padding: 0 20px;
    font-size: 14px;
    pointer-events: none;
    user-select:none;
    z-index: 10;
  }
  #weaponUI {
    background: rgba(0,0,0,0.5);
    padding: 8px 12px;
    border-radius: 8px;
  }
  #ultBarContainer {
    position: relative;
    width: 150px;
    height: 20px;
    background: rgba(255,255,255,0.2);
    border-radius: 10px;
    overflow: hidden;
  }
  #ultBar {
    position: absolute;
    left: 0; top: 0; bottom: 0;
    width: 0%;
    background: linear-gradient(90deg, #f8f8f8 0%, #c6f4ff 100%);
    border-radius: 10px;
    transition: width 0.3s ease;
  }
  #saveLoadUI {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-size: 14px;
    user-select:none;
    z-index: 10;
  }
  #saveLoadUI button {
    margin-right: 8px;
    background: #222;
    border: none;
    color: white;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
  }
</style>
</head>
<body>
  <div id="titleScreen">
    <h1>ULTRA MILK</h1>
    <div id="loadingBarContainer">
      <div id="loadingBar"></div>
    </div>
  </div>
  <div id="pauseMenu" tabindex="0" aria-modal="true" role="dialog">
    <div id="pauseLeft">
      <button id="exitBtn" tabindex="1">Exit to Menu</button>
    </div>
    <div id="pauseRight">
      <div id="milkmanSprite" aria-label="Milkman character"></div>
      <div id="weaponSlots">
        <div class="weaponSlot" id="primarySlot" aria-label="Primary weapon">Shotgun</div>
        <div class="weaponSlot" id="pistolSlot" aria-label="Pistol weapon">Pistol</div>
      </div>
    </div>
  </div>
  <div id="crosshair" aria-hidden="true"></div>
  <div id="hud" aria-live="polite" aria-atomic="true">
    <div id="weaponUI">Weapon: Shotgun</div>
    <div id="ultBarContainer" title="Ultimate Charge">
      <div id="ultBar"></div>
    </div>
  </div>
  <div id="saveLoadUI" style="z-index:10;">
    <button id="saveBtn">Save</button>
    <button id="loadBtn">Load</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
  <script>
(() => {
  // --- VARIABLES ---
  const titleScreen = document.getElementById('titleScreen');
  const loadingBar = document.getElementById('loadingBar');
  const pauseMenu = document.getElementById('pauseMenu');
  const exitBtn = document.getElementById('exitBtn');
  const weaponUI = document.getElementById('weaponUI');
  const ultBar = document.getElementById('ultBar');
  const saveBtn = document.getElementById('saveBtn');
  const loadBtn = document.getElementById('loadBtn');
  const primarySlot = document.getElementById('primarySlot');
  const pistolSlot = document.getElementById('pistolSlot');

  // --- GAME STATE ---
  let gameStarted = false;
  let paused = false;
  let level = 1;
  let ultCharge = 0;
  let keys = {};
  let weapons = ['pistol', 'shotgun', 'knife'];
  let currentWeaponIndex = 1; // start shotgun
  let currentWeapon = weapons[currentWeaponIndex];
  let killsForUlt = 0;
  let player = { pos: new THREE.Vector3(0, 0, 0), speed: 0.12 };
  let enemies = [];
  let bullets = [];
  let ultActive = false;

  // --- LOADING BAR ---
  let loadProgress = 0;
  const loadDuration = 4000; // 4 seconds
  let loadStart = null;
  function updateLoadingBar(time) {
    if(!loadStart) loadStart = time;
    loadProgress = Math.min((time - loadStart) / loadDuration, 1);
    loadingBar.style.width = (loadProgress * 100) + '%';

    if(loadProgress < 1) {
      requestAnimationFrame(updateLoadingBar);
    } else {
      titleScreen.style.display = 'none';
      gameStarted = true;
      initThree();
      spawnLevel(level);
      animate();
      updateUI();
      setupInput();
    }
  }

  window.addEventListener('load', () => {
    requestAnimationFrame(updateLoadingBar);
  });

  // --- THREE.JS SETUP ---
  let scene, camera, renderer, clock;
  function initThree() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 5);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
    scene.add(hemiLight);

    const groundGeo = new THREE.PlaneGeometry(100, 100);
    const groundMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    clock = new THREE.Clock();
  }

  // --- ENEMY SPAWN & MANAGEMENT ---
  function spawnLevel(levelNum) {
    clearEnemies();
    let enemyCount = 5 + levelNum * 2;
    for(let i=0; i<enemyCount; i++) {
      spawnEnemy('melee', randomPosInRange(20));
    }
    for(let i=0; i<2; i++) {
      spawnEnemy('miniboss', randomPosInRange(15));
    }
    if(levelNum >= 3) {
      spawnEnemy('boss', new THREE.Vector3(0,0,-25));
    }
  }
  function clearEnemies() {
    enemies.forEach(e => scene.remove(e.mesh));
    enemies = [];
  }
  function spawnEnemy(type, pos) {
    const geometry = new THREE.BoxGeometry(type==='boss'?3:1, type==='boss'?4:2, type==='boss'?3:1);
    let color = 0xff0000;
    if(type==='miniboss') color = 0xff7700;
    else if(type==='boss') color = 0x990000;
    const material = new THREE.MeshLambertMaterial({ color });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.copy(pos);
    scene.add(mesh);
    enemies.push({ type, mesh, health: type==='boss'? 20 : (type==='miniboss'? 5 : 1), speed: 0.04 + level*0.01, alive: true });
  }
  function randomPosInRange(range) {
    let x = (Math.random() - 0.5) * range * 2;
    let z = (Math.random() - 0.5) * range * 2;
    return new THREE.Vector3(x, 0, z);
  }

  // --- ANIMATION LOOP ---
  function animate() {
    if(!gameStarted || paused) {
      requestAnimationFrame(animate);
      return;
    }

    let delta = clock.getDelta();

    // Simple player movement
    if(keys["w"]) player.pos.z -= player.speed;
    if(keys["s"]) player.pos.z += player.speed;
    if(keys["a"]) player.pos.x -= player.speed;
    if(keys["d"]) player.pos.x += player.speed;

    // Update camera position to player pos + fixed height
    camera.position.set(player.pos.x, 2, player.pos.z + 5);
    camera.lookAt(player.pos.x, 1, player.pos.z);

    // Enemies basic AI (follow player)
    enemies.forEach(e => {
      if(!e.alive) return;
      let dir = new THREE.Vector3().subVectors(player.pos, e.mesh.position);
      if(dir.length() > 0.1) {
        dir.normalize();
        e.mesh.position.add(dir.multiplyScalar(e.speed));
      }
    });

    // Bullets movement and collision (simplified)
    bullets.forEach((b,i) => {
      b.mesh.position.add(b.dir.clone().multiplyScalar(b.speed));
      enemies.forEach(e => {
        if(!e.alive) return;
        if(b.mesh.position.distanceTo(e.mesh.position) < 1) {
          e.health -= b.damage;
          b.toRemove = true;
          if(e.health <= 0) {
            e.alive = false;
            scene.remove(e.mesh);
            onEnemyKilled(e);
          }
        }
      });
      if(b.toRemove) {
        scene.remove(b.mesh);
        bullets.splice(i,1);
      }
    });

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  // --- ENEMY KILLED HANDLER ---
  function onEnemyKilled(enemy) {
    killsForUlt++;
    addUltCharge(enemy.type === 'miniboss' ? 10 : (enemy.type === 'boss' ? 50 : 2));
    // Auto regen shotgun ammo on kill
    if(currentWeapon === 'shotgun') {
      shotgunAmmo = Math.min(shotgunAmmo + 1, maxShotgunAmmo);
      updateUI();
    }
  }

  // --- ULTIMATE ---
  function addUltCharge(amount) {
    ultCharge = Math.min(ultCharge + amount, 100);
    updateUI();
  }
  function useUlt() {
    if(ultCharge < 100) return false;
    ultCharge = 0;
    updateUI();
    // Blast enemies near player
    enemies.forEach(e => {
      if(!e.alive) return;
      if(e.mesh.position.distanceTo(player.pos) < 10) {
        e.alive = false;
        scene.remove(e.mesh);
      }
    });
    return true;
  }

  // --- INPUT ---
  let shotgunAmmo = 6;
  const maxShotgunAmmo = 6;
  function setupInput() {
    window.addEventListener('keydown', (e) => {
      if(e.repeat) return;
      keys[e.key.toLowerCase()] = true;
      if(e.key === 'Escape') togglePause();
      else if(e.key === 'x' || e.key === 'X') {
        if(useUlt()) console.log("ULT used!");
      } else if(e.key === '1') selectWeapon(0);
      else if(e.key === '2') selectWeapon(1);
      else if(e.key === '3') selectWeapon(2);
      else if(e.button === 2) dash(); // Right click dash alternative
    });
    window.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });
    window.addEventListener('mousedown', (e) => {
      if(paused) return;
      if(e.button === 0) shoot();
      else if(e.button === 2) dash();
    });
    // Disable context menu on right click for dash
    window.addEventListener('contextmenu', e => e.preventDefault());
  }

  function selectWeapon(index) {
    if(index < 0 || index >= weapons.length) return;
    currentWeaponIndex = index;
    currentWeapon = weapons[currentWeaponIndex];
    updateUI();
  }

  function shoot() {
    if(currentWeapon === 'shotgun' && shotgunAmmo <= 0) {
      console.log("Shotgun empty");
      return;
    }
    if(currentWeapon === 'shotgun') shotgunAmmo--;

    // Spawn bullet
    const bulletGeo = new THREE.SphereGeometry(0.1, 8, 8);
    const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
    const bulletMesh = new THREE.Mesh(bulletGeo, bulletMat);
    bulletMesh.position.copy(player.pos).add(new THREE.Vector3(0, 1, 0));
    scene.add(bulletMesh);
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
    bullets.push({ mesh: bulletMesh, dir: forward, speed: 0.8, damage: currentWeapon === 'shotgun' ? 3 : 1, toRemove:false });
  }

  function dash() {
    // Move player forward fast a short distance
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
    player.pos.add(forward.multiplyScalar(3));
  }

  // --- PAUSE MENU ---
  function togglePause() {
    paused = !paused;
    pauseMenu.style.display = paused ? 'flex' : 'none';
  }
  exitBtn.onclick = () => {
    location.reload(); // For demo: reload page to "exit to menu"
  };

  // --- UI UPDATE ---
  function updateUI() {
    weaponUI.textContent = `Weapon: ${currentWeapon.charAt(0).toUpperCase() + currentWeapon.slice(1)}` + (currentWeapon === 'shotgun' ? ` (${shotgunAmmo}/${maxShotgunAmmo})` : '');
    ultBar.style.width = ultCharge + '%';
    primarySlot.textContent = currentWeapon === 'pistol' ? 'Rifle' : 'Shotgun';
    pistolSlot.textContent = 'Pistol';
  }

  // --- SAVE / LOAD ---
  saveBtn.onclick = () => {
    const saveData = {
      level,
      ultCharge,
      killsForUlt,
      currentWeaponIndex,
      shotgunAmmo,
      playerPos: { x: player.pos.x, y: player.pos.y, z: player.pos.z }
    };
    const blob = new Blob([JSON.stringify(saveData)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ultra_milk_save.json';
    a.click();
    URL.revokeObjectURL(url);
  };
  loadBtn.onclick = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = e => {
      const file = e.target.files[0];
      if(!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        try {
          const data = JSON.parse(evt.target.result);
          level = data.level || 1;
          ultCharge = data.ultCharge || 0;
          killsForUlt = data.killsForUlt || 0;
          currentWeapon
