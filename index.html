<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ULTRA MILK — Minimal</title>
  <style>
    html,body{height:100%;margin:0;background:#111}
    canvas{display:block}
    /* Crosshair */
    .crosshair{
      position:fixed;left:50%;top:50%;width:20px;height:20px;margin:-10px 0 0 -10px;pointer-events:none;z-index:10;
      display:flex;align-items:center;justify-content:center;
    }
    .crosshair:before{content:'';width:2px;height:12px;background:#fff;border-radius:2px}
    .crosshair:after{content:'';height:2px;width:12px;background:#fff;border-radius:2px;position:absolute}
    /* Quick HUD */
    .hud{position:fixed;left:16px;bottom:16px;color:#ddd;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;z-index:10;opacity:0.9}
    .hint{position:fixed;right:16px;bottom:16px;color:#aaa;font-family:monospace;z-index:10}
  </style>
</head>
<body>
  <div class="crosshair"></div>
  <div class="hud">ULTRA MILK — Minimal</div>
  <div class="hint">Click to lock pointer • WASD to move • Shift to sprint</div>

  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script>
    // Minimal ULTRA MILK: flat plane + free-camera (pointer lock + WASD)

    // Scene, camera, renderer
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x6aa0ff); // sky-like

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 5); // player eye height

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    const amb = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5,10,2);
    scene.add(dir);

    // Ground plane
    const groundGeo = new THREE.PlaneGeometry(200,200);
    const groundMat = new THREE.MeshStandardMaterial({color:0x6f9450, metalness:0.1, roughness:0.9});
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Some props: a few boxes for visual reference
    const boxGeo = new THREE.BoxGeometry(1,1,1);
    const boxMat = new THREE.MeshStandardMaterial({color:0xffffff});
    for(let i=0;i<12;i++){
      const m = new THREE.Mesh(boxGeo, boxMat.clone());
      m.material.color.setHSL(Math.random()*0.2+0.05,0.6,0.5);
      m.position.set((Math.random()-0.5)*50,0.5,(Math.random()-0.5)*50);
      m.rotation.y = Math.random()*Math.PI*2;
      scene.add(m);
    }

    // Controls state
    const keys = {w:false,a:false,s:false,d:false,shift:false};
    window.addEventListener('keydown', e => {
      if(e.code === 'KeyW') keys.w = true;
      if(e.code === 'KeyA') keys.a = true;
      if(e.code === 'KeyS') keys.s = true;
      if(e.code === 'KeyD') keys.d = true;
      if(e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.shift = true;
    });
    window.addEventListener('keyup', e => {
      if(e.code === 'KeyW') keys.w = false;
      if(e.code === 'KeyA') keys.a = false;
      if(e.code === 'KeyS') keys.s = false;
      if(e.code === 'KeyD') keys.d = false;
      if(e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.shift = false;
    });

    // Pointer lock & mouse look
    let yaw = 0, pitch = 0; // radians
    const PI_2 = Math.PI/2;
    function onMouseMove(e){
      if(document.pointerLockElement !== renderer.domElement) return;
      const movementX = e.movementX || 0;
      const movementY = e.movementY || 0;
      const sensitivity = 0.002;
      yaw -= movementX * sensitivity;
      pitch -= movementY * sensitivity;
      pitch = Math.max(-PI_2 + 0.01, Math.min(PI_2 - 0.01, pitch));
    }
    document.addEventListener('mousemove', onMouseMove, false);

    renderer.domElement.addEventListener('click', ()=>{
      renderer.domElement.requestPointerLock();
    });

    // Resize
    window.addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // Movement update
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const up = new THREE.Vector3(0,1,0);

    const clock = new THREE.Clock();

    function animate(){
      const dt = Math.min(0.05, clock.getDelta());

      // Build forward/right vectors from yaw
      const cosYaw = Math.cos(yaw);
      const sinYaw = Math.sin(yaw);
      const forward = new THREE.Vector3(-sinYaw, 0, -cosYaw).normalize();
      const right = new THREE.Vector3(cosYaw, 0, -sinYaw).normalize();

      direction.set(0,0,0);
      if(keys.w) direction.add(forward);
      if(keys.s) direction.add(forward.clone().negate());
      if(keys.a) direction.add(right.clone().negate());
      if(keys.d) direction.add(right);
      direction.normalize();

      const baseSpeed = keys.shift ? 10 : 4; // m/s (sprint if shift)
      // Smooth acceleration
      const target = direction.multiplyScalar(baseSpeed);
      velocity.lerp(target, 1 - Math.pow(0.001, dt));

      // Move camera horizontally (keep y constant)
      camera.position.addScaledVector(velocity, dt);
      camera.position.y = 1.6; // enforce eye height on flat plane

      // Apply rotation from yaw/pitch
      camera.rotation.set(pitch, yaw, 0, 'YXZ');

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate();

    // Friendly fallback if pointer lock denied: show mouse cursor and let user drag
    // (Already handled: pointer lock required for mouse-look, otherwise user can still use keyboard to move)

    // Prevent context menu on right-click
    window.addEventListener('contextmenu', e=>e.preventDefault());

  </script>
</body>
</html>
