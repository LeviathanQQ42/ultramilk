<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8"><title>Milkman FPS v2.1</title>
<style>
  html, body { margin:0; padding:0; overflow:hidden; background:#111; font-family:monospace; }
  #ui-bl { position:fixed; bottom:10px; left:10px; color:#0ff; z-index:10; }
  #ui-tr { position:fixed; top:10px; left:10px; color:#0ff; z-index:10; }
  #ui-br { position:fixed; bottom:10px; right:10px; color:#0ff; z-index:10; font-size:18px; }
  #ui-br span { text-transform: uppercase; }
  button { background:#222; border:none; color:#0ff; padding:5px 10px; margin:5px; cursor:pointer; font-size:14px; }
  button:hover { background:#0ff; color:#111; }
  #loading, #tapToStart, #pauseOverlay, #levelChoice { position:fixed; width:100%; text-align:center; color:#0ff; z-index:20; }
  #loading { top:45%; font-size:24px; }
  #tapToStart { top:40%; font-size:28px; cursor:pointer; }
  #pauseOverlay { top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); display:none; }
  #pauseOverlay h1 { margin-top:30px; }
  #levelChoice { top:35%; font-size:24px; display:none; }
  canvas { image-rendering: pixelated; }
</style>
</head>
<body>
  <div id="ui-bl"><div id="health">Health: 100</div><div id="ult">Ult: 0%</div></div>
  <div id="ui-tr">
    <button id="saveBtn">Save Game</button>
    <button id="loadBtn">Load Game</button>
    <input type="file" id="loadInput" style="display:none" accept=".ultra,.json" />
  </div>
  <div id="ui-br">Weapon: <span id="weaponDisplay">Pistol</span><br>Shotgun Ammo: <span id="shotgunAmmo">8</span></div>

  <div id="loading">Loading... please wait</div>
  <div id="tapToStart">Tap or Click to Start</div>
  <div id="pauseOverlay">
    <h1>Paused</h1>
    <button id="resumeBtn">Resume</button><button id="pauseSaveBtn">Save Game</button><button id="pauseLoadBtn">Load Game</button>
  </div>
  <div id="levelChoice">
    <div>Level Complete! Choose your next weapon:</div>
    <button id="chooseRifle">Rifle (infinite ammo)</button>
    <button id="chooseShotgun">Shotgun (regen per kill)</button>
  </div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>

<script>
(() => {
  // Constants
  const HEALTH_MAX=100, ULT_MAX=100;
  const ULT_BASIC=2, ULT_MINI=10;
  const MOVE_SPEED=5, DASH_SPEED=20, DASH_CD=1;
  const SHOT_AMMO_MAX=8;
  const LEVEL_COUNT=2;

  // State
  let health=HEALTH_MAX, ult=0, shotgunAmmo=SHOT_AMMO_MAX;
  let weapon='pistol', dashTimer=0, canDash=true;
  let paused=false, started=false, currentLevel=1;
  let styleScore=0;

  // HTML elements
  const healthEl = document.getElementById('health');
  const ultEl = document.getElementById('ult');
  const weaponEl = document.getElementById('weaponDisplay');
  const shotgunEl = document.getElementById('shotgunAmmo');
  const saveBtn=document.getElementById('saveBtn'), loadBtn=document.getElementById('loadBtn'), loadInput=document.getElementById('loadInput');
  const tapStart=document.getElementById('tapToStart'), loading=document.getElementById('loading');
  const pauseOv=document.getElementById('pauseOverlay'), resumeBtn=document.getElementById('resumeBtn');
  const pauseSaveBtn=document.getElementById('pauseSaveBtn'), pauseLoadBtn=document.getElementById('pauseLoadBtn');
  const choiceOv=document.getElementById('levelChoice'), btnRifle=document.getElementById('chooseRifle'), btnSG=document.getElementById('chooseShotgun');

  function updateHUD(){
    healthEl.textContent=`Health: ${health}`;
    ultEl.textContent=`Ult: ${Math.floor(ult)}%`;
    weaponEl.textContent = weapon.charAt(0).toUpperCase()+weapon.slice(1);
    shotgunEl.textContent = shotgunAmmo;
  }

  function saveData(){
    return { health, ult, shotgunAmmo, weapon, currentLevel, styleScore };
  }
  function loadData(d){
    if(!d) return;
    health = d.health || health;
    ult = d.ult || ult;
    shotgunAmmo = d.shotgunAmmo!==undefined ? d.shotgunAmmo : shotgunAmmo;
    weapon = d.weapon || weapon;
    currentLevel = d.currentLevel || currentLevel;
    styleScore = d.styleScore || styleScore;
    updateHUD();
  }
  function downloadSave(){
    const blob = new Blob([JSON.stringify(saveData())],{type:'application/json'});
    const a = document.createElement('a');
    a.href=URL.createObjectURL(blob); a.download='savegame.ultra'; a.click();
    URL.revokeObjectURL(a.href);
  }

  saveBtn.onclick=downloadSave; pauseSaveBtn.onclick=downloadSave;
  loadBtn.onclick=()=>loadInput.click(); pauseLoadBtn.onclick=()=>loadInput.click();
  loadInput.onchange=e=>{
    const f=e.target.files[0];
    if(!f) return;
    const r=new FileReader();
    r.onload=evt=>loadData(JSON.parse(evt.target.result));
    r.readAsText(f);
  }

  resumeBtn.onclick=()=>{ paused=false; pauseOv.style.display='none'; };

  window.addEventListener('keydown',e=>{
    if(e.code==='Escape'){
      paused=!paused;
      pauseOv.style.display = paused ? 'block' : 'none';
    }
    if(e.code==='Digit1'){ weapon='pistol'; updateHUD(); }
    if(e.code==='Digit2'){ weapon='shotgun'; updateHUD(); }
    if(e.code==='Digit3'){ weapon='knife'; updateHUD(); }
    if(e.code==='KeyX') useUlt();
  });

  tapStart.addEventListener('click',()=>{
    if(!started){
      started = true; tapStart.style.display='none';
      controls.lock();
    }
  });

  btnRifle.onclick = () => { weapon='rifle'; levelAdvance(); };
  btnSG.onclick = () => { weapon='shotgun'; levelAdvance(); };

  // Three.js setup
  let scene, camera, renderer, controls, clock = new THREE.Clock();
  let enemies = [], bullets = [];

  async function init() {
    scene = new THREE.Scene(); scene.background = new THREE.Color(0x111111);
    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0,1.6,0);
    renderer = new THREE.WebGLRenderer({antialias:false});
    renderer.setSize(innerWidth, innerHeight); renderer.domElement.style.imageRendering='pixelated';
    document.body.appendChild(renderer.domElement);
    window.addEventListener('resize',()=>{
      camera.aspect=innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    const ambient = new THREE.AmbientLight(0x888888); scene.add(ambient);
    const dl = new THREE.DirectionalLight(0xffffff,0.6); dl.position.set(10,20,10); scene.add(dl);
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(50,50),
      new THREE.MeshBasicMaterial({color:0x222244}));
    floor.rotation.x = -Math.PI/2; scene.add(floor);

    controls = new THREE.PointerLockControls(camera, document.body);
    document.body.addEventListener('click',()=>{ if(started) controls.lock(); });

    loadData(JSON.parse(localStorage.getItem('lastSave')|| '{}'));
    updateHUD();

    spawnLevel();
    loading.style.display='none';
    animate();
  }

  function animate(){
    requestAnimationFrame(animate);
    if(!started||paused) return;
    const dt = clock.getDelta();
    updatePlayer(dt);
    updateEnemies(dt);
    updateBullets(dt);
    renderer.render(scene,camera);
  }

  function updatePlayer(dt){
    // movement + dash + shoot + melee
    // regen shotgunAmmo on kill is handled inside kill logic
    // implement shooting, melee range detection...
  }

  function updateEnemies(dt){
    // move toward player; ranged shooters fire
    // detect kill, add ult + shotgun regen
  }

  function updateBullets(dt){
    // bullet travel, hit detection, remove if out-of-range
  }

  function useUlt(){
    if(ult<ULT_MAX) return;
    ult=0; updateHUD();
    const pos = controls.getObject().position;
    [...enemies].forEach(e=>{
      if(e.mesh.position.distanceTo(pos) < 10){
        killEnemy(e);
      }
    });
  }

  function spawnLevel(){
    // Clear previous
    enemies.forEach(e=>scene.remove(e.mesh));
    enemies = [];
    // spawn basic, ranged, 2 miniboss, and final boss if last
  }

  function killEnemy(enemy){
    enemy.alive=false;
    scene.remove(enemy.mesh);
    addUlt(enemy.isMini?ULT_MINI:ULT_BASIC);
    if(weapon==='shotgun') shotgunAmmo = Math.min(shotgunAmmo+1, SHOT_AMMO_MAX);
    updateHUD();
    styleScore+= enemy.isBoss?2000:enemy.isMini?500:100;
    if(checkLevelClear()) showLevelChoice();
  }

  function addUlt(n){ ult = Math.min(ult+n, ULT_MAX); updateHUD(); }
  function checkLevelClear(){ return enemies.filter(e=>e.alive).length===0; }
  function showLevelChoice(){
    paused=true;
    choiceOv.style.display='block';
  }
  function levelAdvance(){
    choiceOv.style.display='none';
    currentLevel++;
    if(currentLevel>LEVEL_COUNT){
      alert('You win! Style score: '+styleScore);
      currentLevel=1;
    }
    paused=false;
    spawnLevel();
  }

  init();
})();
</script>
</body>
</html>
