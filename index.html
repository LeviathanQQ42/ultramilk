<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fixed FPS with weapons + cube + collisions</title>
<style>
  body,html{margin:0;padding:0;overflow:hidden;background:#1e2e3e;}
  canvas{display:block;}
  .crosshair {
    position: fixed;
    left: 50%; top: 50%;
    width: 20px; height: 20px;
    margin-left: -10px; margin-top: -10px;
    pointer-events:none;
    z-index: 10;
  }
  .crosshair:before, .crosshair:after {
    content: '';
    position: absolute;
    background: white;
    border-radius: 1px;
  }
  .crosshair:before {
    left: 9px; top: 4px; width: 2px; height: 12px;
  }
  .crosshair:after {
    top: 9px; left: 4px; width: 12px; height: 2px;
  }
  #hud {
    position: fixed;
    bottom: 10px; right: 10px;
    color: white;
    font-family: Arial, sans-serif;
    background: rgba(0,0,0,0.4);
    padding: 6px 12px;
    border-radius: 6px;
    user-select:none;
  }
</style>
</head>
<body>
<div class="crosshair"></div>
<div id="hud">Weapon: AR (1=AR 2=Pistol 3=Katana)</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
(() => {
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb); // sky blue

  // Camera setup
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.6, 5);

  // Renderer
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);

  // Ground plane
  const groundMat = new THREE.MeshStandardMaterial({color: 0x446633});
  const groundGeo = new THREE.PlaneGeometry(200, 200);
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  scene.add(ground);

  // Boxes (obstacles)
  const boxMat = new THREE.MeshStandardMaterial({color: 0x554433});
  const boxes = [];
  function createBox(x,y,z,sx,sy,sz){
    const box = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz), boxMat);
    box.position.set(x, y + sy/2, z);
    scene.add(box);
    boxes.push({mesh: box, min: new THREE.Vector3(x - sx/2, y, z - sz/2), max: new THREE.Vector3(x + sx/2, y + sy, z + sz/2)});
  }
  createBox(0,0,0,3,2,3);
  createBox(5,0,5,2,1,2);
  createBox(-4,0,-6,3,3,3);

  // Player state
  const player = {
    pos: new THREE.Vector3(0,1.6,5),
    vel: new THREE.Vector3(),
    radius: 0.35,
    height: 1.6,
    speed: 4,
    onGround: false,
  };

  // Controls
  const keys = {};
  window.addEventListener('keydown', e => keys[e.code] = true);
  window.addEventListener('keyup', e => keys[e.code] = false);

  // Mouse look state
  let yaw = 0, pitch = 0;
  let ignoreMouse = true;

  window.addEventListener('mousemove', e => {
    if (document.pointerLockElement !== renderer.domElement) return;
    if(ignoreMouse){
      ignoreMouse = false;
      return;
    }
    yaw -= e.movementX * 0.0025;
    pitch -= e.movementY * 0.0025;
    pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, pitch));
  });
  renderer.domElement.addEventListener('click', () => renderer.domElement.requestPointerLock());

  // Weapon models attached to camera
  const weaponGroup = new THREE.Group();
  camera.add(weaponGroup);

  // AR weapon
  const ar = new THREE.Group();
  const arBody = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.12,0.18), new THREE.MeshStandardMaterial({color:0x222222}));
  arBody.position.set(0, -0.1, -0.3);
  ar.add(arBody);
  weaponGroup.add(ar);

  // Pistol weapon
  const pistol = new THREE.Group();
  const pBody = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.1,0.12), new THREE.MeshStandardMaterial({color:0x111111}));
  pBody.position.set(0, -0.1, -0.25);
  pistol.add(pBody);

  // Katana weapon (futuristic)
  const katana = new THREE.Group();
  const hilt = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.28, 8), new THREE.MeshStandardMaterial({color:0x222222}));
  hilt.rotation.z = Math.PI/2;
  hilt.position.set(0.05, -0.1, -0.15);
  katana.add(hilt);
  const blade = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.02, 1), new THREE.MeshStandardMaterial({color: 0x00ffff, emissive: 0x00ffff, transparent:true, opacity:0.9}));
  blade.position.set(0.05, -0.1, -0.65);
  katana.add(blade);

  // Start with AR
  let currentWeapon = 'ar';
  weaponGroup.add(ar);

  // HUD
  const hud = document.getElementById('hud');
  function setWeapon(name){
    // Clear previous
    while(weaponGroup.children.length) weaponGroup.remove(weaponGroup.children[0]);
    if(name === 'ar') weaponGroup.add(ar);
    else if(name === 'pistol') weaponGroup.add(pistol);
    else if(name === 'katana') weaponGroup.add(katana);
    currentWeapon = name;
    hud.textContent = `Weapon: ${name.toUpperCase()} (1=AR 2=Pistol 3=Katana)`;
  }

  window.addEventListener('keydown', e => {
    if(e.code === 'Digit1') setWeapon('ar');
    if(e.code === 'Digit2') setWeapon('pistol');
    if(e.code === 'Digit3') setWeapon('katana');
  });

  // Basic collision helper for capsule vs box
  function capsuleBoxCollision(playerPos, playerRadius, playerHeight, box) {
    // We simplify player as a capsule with bottom and top sphere centers
    const bottomSphere = new THREE.Vector3(playerPos.x, playerPos.y - playerHeight/2 + playerRadius, playerPos.z);
    const topSphere = new THREE.Vector3(playerPos.x, playerPos.y + playerHeight/2 - playerRadius, playerPos.z);

    // Clamp the sphere centers to box bounds
    function closestPointToBox(point, boxMin, boxMax) {
      return new THREE.Vector3(
        Math.max(boxMin.x, Math.min(point.x, boxMax.x)),
        Math.max(boxMin.y, Math.min(point.y, boxMax.y)),
        Math.max(boxMin.z, Math.min(point.z, boxMax.z))
      );
    }

    const closestBottom = closestPointToBox(bottomSphere, box.min, box.max);
    const closestTop = closestPointToBox(topSphere, box.min, box.max);

    // Distances
    const distBottom = bottomSphere.distanceTo(closestBottom);
    const distTop = topSphere.distanceTo(closestTop);

    // Check if either sphere intersects the box (distance < radius)
    return (distBottom < playerRadius || distTop < playerRadius);
  }

  // Movement & physics params
  const gravity = 30;
  const jumpVelocity = 8;
  let onGround = false;
  let velocity = new THREE.Vector3();

  // Main loop
  const clock = new THREE.Clock();

  function update(){
    const dt = Math.min(0.05, clock.getDelta());

    // Update camera rotation from yaw/pitch
    camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));

    // Movement input vector
    const direction = new THREE.Vector3();
    if(keys['KeyW']) direction.z -= 1;
    if(keys['KeyS']) direction.z += 1;
    if(keys['KeyA']) direction.x -= 1;
    if(keys['KeyD']) direction.x += 1;
    direction.normalize();

    // Convert direction from local camera space to world space (ignoring pitch)
    const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    forward.y = 0; forward.normalize();
    const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), forward);

    // Calculate movement vector in world space
    const move = new THREE.Vector3();
    move.addScaledVector(forward, direction.z);
    move.addScaledVector(right, direction.x);
    move.normalize();

    // Horizontal velocity update
    velocity.x = move.x * player.speed;
    velocity.z = move.z * player.speed;

    // Gravity
    velocity.y -= gravity * dt;

    // Jumping
    if(keys['Space'] && onGround) {
      velocity.y = jumpVelocity;
      onGround = false;
    }

    // Apply velocity to player position
    player.pos.addScaledVector(velocity, dt);

    // Simple ground collision
    if(player.pos.y < player.height/2) {
      player.pos.y = player.height/2;
      velocity.y = 0;
      onGround = true;
    }

    // Box collisions for player - prevents passing through and allows standing on boxes
    for(let box of boxes) {
      if(capsuleBoxCollision(player.pos, player.radius, player.height, box)) {
        // Push player out along Y axis if above box top
        const boxTop = box.max.y;
        if(player.pos.y - player.height/2 < boxTop) {
          player.pos.y = boxTop + player.height/2;
          velocity.y = 0;
          onGround = true;
        }
      }
    }

    // Set camera position to player position, but camera height offset is half player height
    camera.position.set(player.pos.x, player.pos.y, player.pos.z);

    // Render scene
    renderer.render(scene, camera);
    requestAnimationFrame(update);
  }
  update();

  // Resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

})();
</script>
</body>
</html>
