<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Ultra Milk — Full (Weapons, Enemy, Draggable Cube)</title>
<style>
  html,body{height:100%;margin:0;background:#111;overflow:hidden;font-family:Segoe UI,Roboto,Arial}
  canvas{display:block}
  .crosshair{position:fixed;left:50%;top:50%;width:20px;height:20px;margin:-10px 0 0 -10px;pointer-events:none;z-index:40}
  .crosshair:before{content:'';position:absolute;left:9px;top:4px;width:2px;height:12px;background:#fff;border-radius:1px}
  .crosshair:after{content:'';position:absolute;top:9px;left:4px;height:2px;width:12px;background:#fff;border-radius:1px}
  .hud{position:fixed;right:16px;bottom:16px;background:rgba(0,0,0,0.6);padding:10px 14px;border-radius:8px;color:#e6eef7;z-index:50;text-align:center}
  .hud .weapon{font-size:16px;font-weight:700}
  .hud .small{font-size:13px;color:#9fb0c6}
  .hint{position:fixed;left:12px;bottom:16px;color:#9fb0c6;z-index:50}
  .msg{position:fixed;left:50%;top:12px;transform:translateX(-50%);color:#fff;background:rgba(0,0,0,0.4);padding:6px 10px;border-radius:6px;z-index:60}
</style>
</head>
<body>
  <div class="crosshair"></div>
  <div class="hud">
    <div class="weapon" id="weaponName">AR (Vandal)</div>
    <div class="small">Kills: <span id="kills">0</span></div>
    <div class="small">Swap: 1=AR 2=Pistol 3=Katana</div>
  </div>
  <div class="hint">Click to lock • WASD • Shift sprint • Ctrl+Shift slide • Space jump • E pickup/slash • LMB shoot</div>
  <div class="msg" id="msg" style="display:none;"></div>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script>
/* ----------------------
   Basic scene setup
   ---------------------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x6aa0ff);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dirL = new THREE.DirectionalLight(0xffffff,0.9);
dirL.position.set(5,10,2);
scene.add(dirL);

/* Ground */
const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({color:0x6f9450}));
ground.rotation.x = -Math.PI/2;
scene.add(ground);

/* Obstacles */
const obstacles = [];
function addBox(x,y,z,sx,sy,sz,color){
  const geo = new THREE.BoxGeometry(sx,sy,sz);
  const mat = new THREE.MeshStandardMaterial({color: color||0x777777});
  const m = new THREE.Mesh(geo,mat);
  m.position.set(x,y,z);
  scene.add(m);
  obstacles.push({mesh:m, hx:sx/2, hy:sy/2, hz:sz/2});
  return m;
}
addBox(-6,0.5,-2,2,1,2,0x8a7d6b);
addBox(5,0.5,1,2,1,2,0x8a7d6b);
addBox(0,1,-6,3,2,1,0x666666);
addBox(-4,1,6,3,2,1,0x666666);
addBox(3,0.5,6,3,1,3,0x7b6f57);

/* Draggable cube (physics) */
const cubeSize = 0.8;
const cubeGeo = new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize);
const cubeMat = new THREE.MeshStandardMaterial({color:0x33c3ff});
const physCube = new THREE.Mesh(cubeGeo, cubeMat);
physCube.position.set(0,1.0,2);
scene.add(physCube);
const cubeState = { pos: physCube.position.clone(), vel: new THREE.Vector3(), mass: 2, size: cubeSize, held:false };

/* Player */
const keys = {w:0,a:0,s:0,d:0,shift:0,ctrl:0,space:0};
window.addEventListener('keydown', e=>{
  if(e.code==='KeyW') keys.w=1;
  if(e.code==='KeyA') keys.a=1;
  if(e.code==='KeyS') keys.s=1;
  if(e.code==='KeyD') keys.d=1;
  if(e.code==='ShiftLeft') keys.shift=1;
  if(e.code==='ControlLeft') keys.ctrl=1;
  if(e.code==='Space') keys.space=1;
  if(e.code==='KeyE') onEPress();
  if(e.code==='Digit1') tryEquip('ar');
  if(e.code==='Digit2') tryEquip('pistol');
  if(e.code==='Digit3') tryEquip('katana');
});
window.addEventListener('keyup', e=>{
  if(e.code==='KeyW') keys.w=0;
  if(e.code==='KeyA') keys.a=0;
  if(e.code==='KeyS') keys.s=0;
  if(e.code==='KeyD') keys.d=0;
  if(e.code==='ShiftLeft') keys.shift=0;
  if(e.code==='ControlLeft') keys.ctrl=0;
  if(e.code==='Space') keys.space=0;
});

/* Camera look: clamp deltas and ignore initial spurious events on pointerlock */
let yaw = 0, pitch = 0;
let ignoreMouseUntil = 0;
const mouseClamp = 120; // clamp absurd movement so no snap
window.addEventListener('mousemove', e=>{
  if(document.pointerLockElement !== renderer.domElement) return;
  if(performance.now() < ignoreMouseUntil) return;
  const dx = Math.max(-mouseClamp, Math.min(mouseClamp, e.movementX));
  const dy = Math.max(-mouseClamp, Math.min(mouseClamp, e.movementY));
  yaw -= dx * 0.0025;
  pitch -= dy * 0.0025;
  pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, pitch));
});
renderer.domElement.addEventListener('click', ()=> {
  renderer.domElement.requestPointerLock();
});
document.addEventListener('pointerlockchange', ()=>{
  // ignore mouse events for a short time after pointer lock change (stops initial warp)
  ignoreMouseUntil = performance.now() + 40; // ms
});

/* Player movement state */
let pos = new THREE.Vector3(0,1.6,8);
let vel = new THREE.Vector3();
let onGround = false;
let slideTimer = 0;
let jumpQueued = false;
const playerRadius = 0.35;
const camHeightStand = 1.6, camHeightCrouch = 1.0;
let camHeight = camHeightStand;

const clock = new THREE.Clock();

/* Weapons & HUD */
const weapons = {
  ar: {name:'AR (Vandal)', speed:3.6, cooldown:0.12, dmg:1},
  pistol: {name:'Pistol', speed:4.6, cooldown:0.28, dmg:1},
  katana: {name:'Katana', speed:5.2, cooldown:0.5, dmg:3}
};
let currentWeapon = 'ar';
let kills = 0;
const weaponNameEl = document.getElementById('weaponName');
const killsEl = document.getElementById('kills');
function updateHUD(){ weaponNameEl.textContent = weapons[currentWeapon].name; killsEl.textContent = kills; }
updateHUD();
function showMsg(t,ms=1200){ const el = document.getElementById('msg'); el.textContent = t; el.style.display='block'; setTimeout(()=>el.style.display='none', ms); }

/* Weapon models: attach to camera so they follow view */
const weaponRoot = new THREE.Group();
camera.add(weaponRoot);
// position weaponRoot so it sits in front-right of camera
weaponRoot.position.set(0.25,-0.25,-0.6);

/* AR model — block rifle */
const ar = new THREE.Group();
const arBody = new THREE.Mesh(new THREE.BoxGeometry(0.9,0.12,0.16), new THREE.MeshStandardMaterial({color:0x222222}));
arBody.position.set(0,-0.02,-0.25);
ar.add(arBody);
const arMag = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.18,0.06), new THREE.MeshStandardMaterial({color:0x151515}));
arMag.position.set(-0.18,-0.12,-0.1); ar.add(arMag);
const arBarrel = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.05,0.4), new THREE.MeshStandardMaterial({color:0x2a2a2a}));
arBarrel.position.set(0,-0.02,-0.55);
ar.add(arBarrel);
ar.scale.set(0.9,0.9,0.9);
ar.position.set(0.05,-0.05,0.0);

/* Pistol model — small block */
const pistol = new THREE.Group();
const pBody = new THREE.Mesh(new THREE.BoxGeometry(0.35,0.09,0.12), new THREE.MeshStandardMaterial({color:0x1f1f2a}));
pBody.position.set(0,-0.02,-0.22); pistol.add(pBody);
const pGrip = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.15,0.06), new THREE.MeshStandardMaterial({color:0x111111}));
pGrip.position.set(-0.10,-0.08,-0.14); pistol.add(pGrip);
pistol.scale.set(1,1,1);
pistol.position.set(0.05,-0.05,0);

/* Katana futuristic model */
const kat = new THREE.Group();
// hilt
const hilt = new THREE.Mesh(new THREE.CylinderGeometry(0.025,0.025,0.28,8), new THREE.MeshStandardMaterial({color:0x303030}));
hilt.rotation.z = Math.PI/2; hilt.position.set(0.05,-0.02,-0.12);
kat.add(hilt);
// glowing blade (thin box with emissive)
const blade = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.02,1.0), new THREE.MeshStandardMaterial({color:0x77eeff,emissive:0x33ccff,transparent:true,opacity:0.95}));
blade.position.set(0.05,-0.02,-0.62);
kat.add(blade);
kat.scale.set(0.8,0.8,0.8);
kat.position.set(0.05,-0.05,0);

/* Attach default weapon (AR) */
weaponRoot.add(ar);

/* Enemy */
const enemy = { pos:new THREE.Vector3(0,0.7,-8), size:0.7, health:5, mesh:null, shootCD:0 };
enemy.mesh = new THREE.Mesh(new THREE.SphereGeometry(enemy.size,12,12), new THREE.MeshStandardMaterial({color:0xff6666}));
enemy.mesh.position.copy(enemy.pos);
scene.add(enemy.mesh);

/* Projectiles array */
const projGeo = new THREE.SphereGeometry(0.12,8,8);
const projMat = new THREE.MeshStandardMaterial({color:0xffff77});
const projectiles = [];

/* Shooting */
let canShoot=true, shootCooldown=0;
window.addEventListener('mousedown', e=>{
  if(document.pointerLockElement !== renderer.domElement) return;
  if(e.button !== 0) return;
  if(!canShoot) return;
  if(currentWeapon === 'katana') return;
  // hitscan
  const origin = camera.position.clone();
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
  shootHitscan(origin,dir);
  canShoot=false; shootCooldown = weapons[currentWeapon].cooldown;
});

/* Hitscan check */
function shootHitscan(origin, dir, max=200){
  const toE = enemy.pos.clone().sub(origin);
  const projLen = toE.dot(dir);
  if(projLen > 0 && projLen < max){
    const closestDist = toE.clone().sub(dir.clone().multiplyScalar(projLen)).length();
    if(closestDist < enemy.size){
      enemy.health -= weapons[currentWeapon].dmg;
      if(enemy.health <= 0){
        enemy.health = 5;
        kills++;
        updateHUD();
        // respawn enemy
        enemy.pos.set((Math.random()-0.5)*20, enemy.size, (Math.random()-0.5)*20 - 8);
        enemy.mesh.position.copy(enemy.pos);
      }
    }
  }
}

/* Katana slash */
function katanaSlash(){
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
  const slashPos = pos.clone().add(forward.multiplyScalar(1.2));
  if(slashPos.distanceTo(enemy.pos) < enemy.size + 0.8){
    enemy.health -= weapons.katana.dmg;
    if(enemy.health <= 0){ enemy.health = 5; kills++; updateHUD(); enemy.pos.set((Math.random()-0.5)*20, enemy.size, (Math.random()-0.5)*20 - 8); enemy.mesh.position.copy(enemy.pos); }
  }
}

/* Equip logic with unlocks */
function tryEquip(name){
  if(name === 'pistol' && kills < 2){ showMsg('Pistol unlocks at 2 kills'); return; }
  if(name === 'katana' && kills < 3){ showMsg('Katana unlocks at 3 kills'); return; }
  if(currentWeapon === name) return;
  // remove current model then add new
  weaponRoot.clear();
  currentWeapon = name;
  if(name === 'ar') weaponRoot.add(ar);
  if(name === 'pistol') weaponRoot.add(pistol);
  if(name === 'katana') weaponRoot.add(kat);
  updateHUD();
}

/* E press: pickup or slash */
let holding = false;
const holdDistance = 2.0, holdStiff = 40, holdDamp = 6;
function getLookHitCube(){
  const rayOrigin = camera.position.clone();
  const rayDir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
  const toCube = cubeState.pos.clone().sub(rayOrigin);
  const proj = toCube.dot(rayDir);
  if(proj > 0 && proj < 4.5){
    const closest = toCube.clone().sub(rayDir.clone().multiplyScalar(proj)).length();
    if(closest < cubeState.size*0.9) return {hit:true, dist:proj};
  }
  return {hit:false};
}
function onEPress(){
  const hit = getLookHitCube();
  if(hit.hit && !holding){ holding = true; cubeState.held = true; cubeState.vel.set(0,0,0); }
  else if(holding){ holding = false; cubeState.held = false; }
  else if(currentWeapon === 'katana'){ katanaSlash(); }
}

/* cube physical collision helper */
function cubeCollide(state){
  // ground
  if(state.pos.y - state.size/2 < 0){
    state.pos.y = state.size/2;
    if(state.vel.y < 0) state.vel.y = -state.vel.y * 0.2;
  }
  // obstacles
  obstacles.forEach(o=>{
    const min = o.mesh.position.clone().add(new THREE.Vector3(-o.hx,-o.hy,-o.hz));
    const max = o.mesh.position.clone().add(new THREE.Vector3(o.hx,o.hy,o.hz));
    const cmin = state.pos.clone().addScalar(-state.size/2);
    const cmax = state.pos.clone().addScalar(state.size/2);
    if(cmin.x <= max.x && cmax.x >= min.x &&
       cmin.y <= max.y && cmax.y >= min.y &&
       cmin.z <= max.z && cmax.z >= min.z){
      // smallest overlap axis
      const ox1 = max.x - cmin.x, ox2 = cmax.x - min.x; const ox = Math.min(ox1,ox2);
      const oy1 = max.y - cmin.y, oy2 = cmax.y - min.y; const oy = Math.min(oy1,oy2);
      const oz1 = max.z - cmin.z, oz2 = cmax.z - min.z; const oz = Math.min(oz1,oz2);
      if(ox < oy && ox < oz){ if(state.pos.x < o.mesh.position.x) state.pos.x -= ox; else state.pos.x += ox; state.vel.x=0; }
      else if(oy < oz){ if(state.pos.y < o.mesh.position.y) state.pos.y -= oy; else state.pos.y += oy; state.vel.y=0; }
      else { if(state.pos.z < o.mesh.position.z) state.pos.z -= oz; else state.pos.z += oz; state.vel.z=0; }
    }
  });
}

/* Resize */
window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

/* Main update loop */
let pos = new THREE.Vector3(0,1.6,8);
let vel = new THREE.Vector3();
function update(){
  const dt = Math.min(0.05, clock.getDelta());

  // camera quaternion only from yaw/pitch
  const qPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), pitch);
  const qYaw = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), yaw);
  camera.quaternion.copy(qYaw).multiply(qPitch);

  // gravity
  vel.y -= 20 * dt;
  pos.y += vel.y * dt;
  if(pos.y <= camHeight){ pos.y = camHeight; vel.y = 0; onGround = true; } else onGround=false;

  // movement
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).setY(0).normalize();
  const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion).setY(0).normalize();
  let speed = weapons[currentWeapon].speed;
  if(keys.shift) speed *= 1.9;
  if(slideTimer > 0) speed += 3;
  const moveDir = new THREE.Vector3();
  if(keys.w) moveDir.add(forward);
  if(keys.s) moveDir.add(forward.clone().negate());
  if(keys.a) moveDir.add(right.clone().negate());
  if(keys.d) moveDir.add(right);
  if(moveDir.length()>0) moveDir.normalize();
  pos.addScaledVector(moveDir, speed * dt);

  // slide (simplified, no heavy ops)
  if(keys.ctrl && keys.shift && onGround && slideTimer <= 0){
    slideTimer = 0.45;
    camHeight = camHeightCrouch;
  }
  if(slideTimer > 0){
    slideTimer -= dt;
    if(slideTimer <= 0) camHeight = camHeightStand;
  }

  // jump
  if(keys.space && !jumpQueued){ if(onGround) vel.y = 7.8; jumpQueued = true; }
  if(!keys.space) jumpQueued = false;

  // simple obstacle pushback for player (AABB)
  obstacles.forEach(o=>{
    const pmin = pos.clone().add(new THREE.Vector3(-playerRadius, -1.0, -playerRadius));
    const pmax = pos.clone().add(new THREE.Vector3(playerRadius, 1.0, playerRadius));
    const bmin = o.mesh.position.clone().add(new THREE.Vector3(-o.hx,-o.hy,-o.hz));
    const bmax = o.mesh.position.clone().add(new THREE.Vector3(o.hx,o.hy,o.hz));
    if(pmin.x <= bmax.x && pmax.x >= bmin.x &&
       pmin.y <= bmax.y && pmax.y >= bmin.y &&
       pmin.z <= bmax.z && pmax.z >= bmin.z){
      const overlapX = Math.min(bmax.x - pmin.x, pmax.x - bmin.x);
      const overlapZ = Math.min(bmax.z - pmin.z, pmax.z - bmin.z);
      if(overlapX < overlapZ){ if(pos.x < o.mesh.position.x) pos.x -= overlapX; else pos.x += overlapX; }
      else { if(pos.z < o.mesh.position.z) pos.z -= overlapZ; else pos.z += overlapZ; }
    }
  });

  // cube physics
  if(cubeState.held){
    // spring toward target in front of camera
    const target = camera.position.clone().add(new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).multiplyScalar(holdDistance));
    const toTarget = target.clone().sub(cubeState.pos);
    const force = toTarget.multiplyScalar(holdStiff).sub(cubeState.vel.clone().multiplyScalar(holdDamp));
    const accel = force.clone().divideScalar(cubeState.mass);
    cubeState.vel.addScaledVector(accel, dt);
  } else {
    cubeState.vel.y -= 20 * dt;
  }
  cubeState.pos.addScaledVector(cubeState.vel, dt);
  cubeCollide(cubeState);
  physCube.position.copy(cubeState.pos);

  // enemy AI : chase player on XZ
  const toPlayer = pos.clone().sub(enemy.pos); toPlayer.y=0;
  const dist = toPlayer.length();
  if(dist > 0.3){ enemy.pos.addScaledVector(toPlayer.normalize(), 1.6 * dt); enemy.mesh.position.copy(enemy.pos); }
  // enemy shoot
  if(enemy.shootCD <= 0){
    if(dist < 18){ // spawn projectile
      const m = new THREE.Mesh(projGeo, projMat);
      m.position.copy(enemy.pos).add(new THREE.Vector3(0,0.6,0));
      scene.add(m);
      const dirShoot = pos.clone().sub(enemy.pos); dirShoot.y=0; dirShoot.normalize();
      projectiles.push({mesh:m, vel:dirShoot.multiplyScalar(8), life:4});
      enemy.shootCD = 2.0;
    } else enemy.shootCD = 0.2;
  } else enemy.shootCD -= dt;

  // update projectiles
  for(let i=projectiles.length-1;i>=0;i--){
    const p = projectiles[i];
    p.mesh.position.addScaledVector(p.vel, dt);
    p.life -= dt;
    if(p.mesh.position.distanceTo(pos) < playerRadius + 0.12){
      // hit player — no HP to show; remove
      scene.remove(p.mesh);
      projectiles.splice(i,1);
      continue;
    }
    if(p.life <= 0){ scene.remove(p.mesh); projectiles.splice(i,1); }
  }

  // shooting cooldown
  if(!canShoot){ shootCooldown -= dt; if(shootCooldown <= 0){ canShoot=true; shootCooldown=0; } }

  // weapon unlock auto-switch on kills (but user can manually swap)
  if(kills >= 3 && currentWeapon !== 'katana'){ /* don't auto-switch if user changed; only auto if still ar? */ }
  if(kills >= 2 && currentWeapon === 'ar'){ /* keep ar unless user swaps */ }

  // place weapon visible (weapons are camera children)
  // camera position updated last
  camera.position.copy(pos);

  renderer.render(scene, camera);
  requestAnimationFrame(update);
}
update();

/* Utility: message and testing */
window.addEventListener('keydown', e=>{ if(e.code==='KeyF'){ enemy.pos.set(pos.x + (Math.random()-0.5)*6, enemy.size, pos.z - 8 + (Math.random()-0.5)*6); enemy.mesh.position.copy(enemy.pos); } });

/* Done: initial weapon setup */
function initWeapons(){
  weaponRoot.clear();
  currentWeapon = 'ar';
  weaponRoot.add(ar);
  updateHUD();
}
initWeapons();

</script>
</body>
</html>
